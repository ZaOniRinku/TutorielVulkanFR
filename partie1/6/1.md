# Tutoriel Vulkan en français
## 1.6 - La pipeline graphique - Écriture et compilation des shaders

La pipeline graphique a plusieurs étapes où des *shaders* sont utilisés, le *Vertex shader*, le *Tessellation Control shader*, le *Tesselation Evaluation shader*, le *Geometry shader* et le *Fragment shader*.

Le *Tessellation Control shader*, le *Tesselation Evaluation shader* et le *Geometry shader* sont optionnels et il est possible de créer une pipeline graphique sans spécifier de *Fragment shader* mais dans ce cas, seule l'information de la profondeur du fragment sera sortie. Dans la très grande majorité des cas, une pipeline graphique ne comportera que deux *shaders* : le *Vertex shader* et le *Fragment shader*.

Contrairement à OpenGL, Vulkan ne supporte pas le GLSL mais supporte une représentation intermédiaire appelée [**SPIR-V**](https://www.khronos.org/spir/). L'avantage est le fait qu'il soit techniquement possible d'écrire ses *shaders* en n'importe quel langage, tant qu'il existe un compilateur vers SPIR-V. Heureusement, VulkanSDK nous fournit de quoi compiler du GLSL vers SPIR-V.

Dans ce chapitre, nous allons voir deux façons de compiler des *shaders* depuis du GLSL vers du SPIR-V. La première méthode consistera à pré-compiler les *shaders* avant de lire le SPIR-V dans le programme et la seconde méthode consistera à compiler les *shaders* pendant que le programme est en cours.

Avant de les compiler, nous devons écrire les *shaders*. Tout d'abord nous allons créer un dossier ``shaders`` à la racine du dossier du projet (à côté de ``CMakeLists.txt``). Dans ce dossier ``shaders``, nous allons créer deux fichiers, ``triangle.vert``, le *Vertex shader*, et ``triangle.frag``, le *Fragment shader*. Ce seront les *shaders* qui nous serviront à dessiner notre triangle.

Tout d'abord, ``triangle.vert``, le *Vertex shader* :

```GLSL
#version 460

const vec2 positions[3] = {
	vec2(0.0, -0.5),
	vec2(-0.5, 0.5),
	vec2(0.5, 0.5)
};

const vec3 colors[3] = {
	vec3(1.0, 0.0, 0.0),
	vec3(0.0, 0.0, 1.0),
	vec3(0.0, 0.0, 1.0)
};

layout(location = 0) out vec3 color;

void main() {
	color = colors[gl_VertexIndex];
	gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);
}
```

Pour dessiner un triangle, nous n'avons besoin que de 3 points, nous n'avons donc pas besoin de ``Vertex buffer`` pour contenir les positions et couleurs de nos ``vertices``, puisque le volume de données à utiliser est faible.

À la place, nous allons les indiquer directement dans le *shader* avec le tableau de 3 ``vec2`` (``vec2 positions[3]``) pour les positions, et le tableau de 3 ``vec3`` (``vec3 colors[3]``) pour les couleurs. Le *Vertex shader* est appelé une fois par *vertex*, et pour savoir sur lequel notre *shader* s'exécute, nous pouvons utiliser la constante pré-définie dans le GLSL Vulkan ``gl_VertexIndex`` (en GLSL OpenGL, cette constante pré-définie s'appelle ``gl_VertexID``), qui va, ici, être égale à 0 pour le premier *vertex*, à 1 pour le deuxième *vertex* et à 2 pour le troisième *vertex*.

Les positions sont sur les *Normalized Device Coordinates* (*NDC*), qui vont de -1 à 1 sur *x* et *y*, avec l'origine placée au centre. Nous n'avons pas de 3ème composante *z* puisque notre triangle est aligné avec l'écran.

![Normalized Device Coordinates](images/normalized_device_coordinates.png)

Sur ce graphique, les chiffres en rouge sont les valeurs de ``gl_VertexIndex`` selon le *vertex* traité.

``gl_Position`` est une valeur pré-existante de GLSL qui sert à donner les coordonnées dans le *Clip Space*. Pourtant, il est indiqué juste au-dessus que les positions des *vertices* sont dans le *NDC*... Le *Vertex shader* sort des coordonnées dans le *Clip Space* qui sont des coordonnées homogènes, en 4 dimensions. La 4ème composante, appelée *w*, divise toutes les autres composantes pour donner les *NDC* lors de l'étape de rastérisation, donnant donc :

![Clip Space vers NDC](images/cs_vers_ndc.png)

Ici, *w* est égal à 1, donc les positions des *vertices* à l'entrée seront les mêmes qu'à la sortie.

Les couleurs sont au format RGB (<span style="color:red">*Red*</span>, <span style="color:green">*Green*</span>, <span style="color:blue">*Blue*</span>).

``layout(location = 0) out vec3 color`` signifie que nous allons passer la variable ``color`` au *Fragment shader*, où les fragments récupéreront une valeur interpolée selon leur distance avec les *vertices*. Si on ne souhaite pas interpoler les valeurs sur les fragments, nous pouvons ajouter le qualifiant ``flat`` de cette manière :

``layout(location = 0) flat out vec3 color``

``color`` est simplement égal à la valeur du tableau ``colors`` indexé avec la valeur de la constante pré-définie ``gl_VertexIndex``.

Ensuite, ``triangle.frag``, le *Fragment shader* :

```GLSL
#version 460

layout(location = 0) in vec3 inColor;

layout(location = 0) out vec4 outColor;

void main() {
	outColor = vec4(inColor, 1.0);
}
```

Le *Fragment shader* s'exécute une fois par fragment. Celui-ci est simple, ``layout(location = 0) in vec3 inColor`` récupère la valeur ``layout(location = 0) out vec3 color`` du *Vertex shader*, les noms des variables peuvent être totalement différentes tant que la ``location`` est la même. Si on ne souhaite pas d'interpolation, il faut, ici aussi, ajouter le qualifieur ``flat`` :

``layout(location = 0) flat in vec3 inColor``

``layout(location = 0) out vec4 outColor`` signifie que ``outColor`` sera notre variable contenant la valeur finale pour l'image à la ``location`` 0, qui sera notre *swapchain*. Nous pouvons donc rendre sur plusieurs images en même temps, *Multiple Render Targets* (MRT), si on spécifie plusieurs valeurs de retour, comme ceci :

```CPP
layout(location = 0) out vec4 outColor0;
layout(location = 1) out vec4 outColor1;
layout(location = 2) out vec4 outColor2;
```

Mais ici, nous n'allons rendre que sur une seule image.

Maintenant que les *shaders* sont écrits, nous pouvons les compiler.

### Pré-compilation
Pré-compiler les *shaders* permet de ne pas perdre de temps à compiler les *shaders* en temps-réel (pendant que le programme est en cours). Le désavantage principal est qu'il n'est donc pas possible de mettre à jour ses *shaders* en temps-réel.

Pour pré-compiler les shaders, nous allons nous servir de ``glslangValidator`` qui est fourni avec ``VulkanSDK``. Dans le dossier où est installé ``VulkanSDK`` : ``VulkanSDK/*numero.de.version*/Bin`` devrait figurer ``glslangValidator.exe`` sur Windows ou ``glslangValidator`` sur Linux. Copiez-le et mettez-le dans le dossier ``shaders`` du projet. Ouvrez un terminal dans ce dossier et utilisez ces commandes :

Windows :
```Bash
glslangValidator.exe -V triangle.vert
glslangValidator.exe -V triangle.frag
```

Linux :
```Bash
./glslangValidator -V triangle.vert
./glslangValidator -V triangle.frag
```

``-V`` est l'option permettant de spécifier que le fichier en entrée est écrit avec du **GLSL Vulkan**, qui a [**quelques différences**](https://github.com/KhronosGroup/GLSL/blob/master/extensions/khr/GL_KHR_vulkan_glsl.txt) avec le GLSL original fait pour OpenGL. Si vous voulez connaitre les options disponibles pour glslangValidator, entrez la commande ``glslangValidator.exe --help`` sur Windows ou ``./glslangValidator --help`` sur Linux. S'il y a des erreurs lors de la compilation, elles s'afficheront dans le terminal.

Une fois ces commandes exécutées, vous vous retrouvez avec deux nouveaux fichiers : ``vert.spv``, qui est ``triangle.vert`` compilé en SPIR-V, et ``frag.spv``, qui est ``triangle.frag`` compilé en SPIR-V. Si vous essayez de les ouvrir, vous n'arriverez pas à les lire car le SPIR-V est un langage binaire.

Nous allons maintenant lire ce fichier dans notre programme. Dans la classe ``HelloTriangle``, on ajoute une méthode privée qui va servir à lire le *shader* en binaire :

```CPP
#include <string> // A mettre avec les autres includes en haut du fichier

std::string readBinaryFile(const std::string& filePath);
```

Puis l'implémentation dans ``hellotriangle.cpp`` :

```CPP
#include <fstream> // A mettre avec les autres includes en haut du fichier

std::string HelloTriangle::readBinaryFile(const std::string& filePath) {
	std::ifstream file(filePath, std::ios::in | std::ios::binary);
	if (!file.is_open()) {
		std::cout << "Le fichier \"" << filePath << "\" n'a pas pu etre ouvert." << std::endl;
		exit(1);
	}
	std::string fileContent((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
	return fileContent;
}
```

On ouvre le fichier en lecture seulement (``std::ios::in``) et en tant que contenu binaire (``std::ios::binary``). Si le fichier ne s'ouvre pas, soit parce qu'il n'existe pas, soit parce que l'utilisateur n'a pas les droits de lecture sur le fichier, on quitte le programme. Sinon, on lit le fichier dans un ``std::string`` qu'on retourne.

[**Chapitre précédent**](../6.md) - [**Index**](../../index.md) - [**Chapitre suivant**](2.md)

[**Code de la partie**](https://github.com/ZaOniRinku/TutorielVulkanFR/tree/partie1/6-1)