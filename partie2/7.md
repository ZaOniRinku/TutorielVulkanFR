# [Tutoriel pour bien débuter à Vulkan](../index.md)
## 2.7 - Utilisation de textures

Actuellement, nous avons nos coordonnées de texture dans le *Fragment Shader* et nous nous en servons comme couleur, il est maintenant de temps de s'en servir pour utiliser des textures.

Nous allons avoir besoin de plusieurs attributs dans la classe ``RenderingEngine`` :

```CPP
std::vector<VkImage> m_textureImages;
std::vector<VkImageView> m_textureImageViews;
std::vector<VmaAllocation> m_textureImageAllocations;
VkSampler m_textureSampler;
```

Ainsi que d'une nouvelle méthode pour créer une texture :

```CPP
void createTexture();
```

Que nous allons implémenter dans ``renderingengine.cpp`` :

```
void RenderingEngine::createTexture() {
	std::array<unsigned char, 16 * 16 * 4> textureData;
	for (size_t i = 0; i < 256; i++) {
		textureData[i * 4] = static_cast<unsigned char>(255 - i); // Rouge
		textureData[i * 4 + 1] = static_cast<unsigned char>(i % 128); // Vert
		textureData[i * 4 + 2] = static_cast<unsigned char>(i); // Bleu
		textureData[i * 4 + 3] = static_cast<unsigned char>(255); // Alpha
	}
}
```

Nous allons définir une image de taille 16 pixels par 16 pixels à la main. Notre texture sera au format RGBA (<span style="color:red">*Red*</span>, <span style="color:green">*Green*</span>, <span style="color:blue">*Blue*</span>, *Alpha*), donc 4 composantes, et chaque composante sera de la taille d'un caractère non-signé, soit 8 bits, les valeurs allant donc de 0 à 255. ``textureData`` va donc contenir les pixels de notre texture.

Nous allons ensuite ajouter une autre méthode privée nous permettant de calculer le nombre de niveaux de mipmaps selon la largeur et la hauteur d'une l'image :

```CPP
uint32_t findMipLevels(uint32_t width, uint32_t height);
```

Implémentée dans ``renderingengine.cpp`` :

```CPP
uint32_t RenderingEngine::findMipLevels(uint32_t width, uint32_t height) {
	return static_cast<uint32_t>(std::floor(std::log2(std::min(width, height)) + 1));
}
```

![Niveaux de mipmaps](images/niveaux_mipmaps.png)

Les mipmaps d'une image sont deux fois plus petits que le niveau précédent. On doit donc trouver quand est-ce qu'on ne peut plus diviser soit la largeur, soit la hauteur, par 2. En utilisant des textures avec des tailles qui sont des puissances de 2, on peut donc aller jusqu'à un niveau de mipmap final n'ayant qu'un seul pixel.

Lorsque le *Fragment Shader* lit dans une texture, il va déterminer le niveau de mipmap adapté à utiliser selon la distance du fragment avec la caméra.

Avoir des mipmaps prend un peu plus d'espace dans la mémoire qu'une image sans mipmap mais présentent deux avantages conséquents :
- Un meilleur accès en mémoire aux textures quand les fragments sont éloignés de la caméra.
- Permet d'éviter les motifs de moiré.

![Mipmaps Moiré](images/mipmap_moire.png)

Les motifs de moiré sont reconnaissables à leurs étranges lignes et courbes. Ils apparaissent lorsque nous n'échantillonnons pas suffisemment des signaux hautes fréquences. Il se trouve que nos textures sont des signaux hautes fréquences et que lorsque les objets apparaissent petits, notamment quand ils sont loins, trop peu de pixels sont échantillonnés par rapport à l'image de base. Les mipmaps sont plus petits, l'échantillonnage est donc meilleur et permet d'éviter ce problème.

Nous allons ensuite créer l'image de notre texture :

```CPP
VkImage textureImage;
VmaAllocation textureImageAllocation;

VkImageCreateInfo textureImageCreateInfo = {};
textureImageCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
textureImageCreateInfo.pNext = nullptr;
textureImageCreateInfo.flags = 0;
textureImageCreateInfo.imageType = VK_IMAGE_TYPE_2D;
textureImageCreateInfo.format = VK_FORMAT_R8G8B8A8_SRGB;
textureImageCreateInfo.extent.width = 16;
textureImageCreateInfo.extent.height = 16;
textureImageCreateInfo.extent.depth = 1;
textureImageCreateInfo.mipLevels = findMipLevels(textureImageCreateInfo.extent.width, textureImageCreateInfo.extent.height);
textureImageCreateInfo.arrayLayers = 1;
textureImageCreateInfo.samples = VK_SAMPLE_COUNT_1_BIT;
textureImageCreateInfo.tiling = VK_IMAGE_TILING_OPTIMAL;
textureImageCreateInfo.usage = VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT;
textureImageCreateInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
textureImageCreateInfo.queueFamilyIndexCount = 1;
textureImageCreateInfo.pQueueFamilyIndices = &m_graphicsQueueFamilyIndex;
textureImageCreateInfo.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED;

VmaAllocationCreateInfo textureImageAllocationCreateInfo = {};
textureImageAllocationCreateInfo.usage = VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE;

TUTORIEL_VK_CHECK(vmaCreateImage(m_allocator, &textureImageCreateInfo, &textureImageAllocationCreateInfo, &textureImage, &textureImageAllocation, nullptr));
```

Comme pour la création de l'image de profondeur, nous utilisons la structure [**``VkImageCreateInfo``**](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageCreateInfo.html) pour créer une image.

Comme expliqué lorsque nous avons écrit les pixels de notre image juste avant, le ``format`` est RGBA où chaque composante fait un octet, ou 8 bits, nous avons donc ``VK_FORMAT_R8G8B8A8_SRGB``. Nous utilisons la version ``SRGB`` de ce format car nous allons traiter des couleurs ici. Les formats ``UNORM`` sont plutôt à utiliser lorsque nous ne traitons pas des couleurs mais plutôt des valeurs, comme sur les images de normales (*Normal Map*), où le rouge sera l'axe x de la normale, le vert sera l'axe y de la normale et le bleu sera l'axe z de la normale.

Notre image est de taille 16 pixels par 16 pixels, ``extent.width`` et ``extent.height`` sont donc égaux à 16.

``mipLevels`` sera le nombre de niveaux de mipmaps, et utilise la fonction ``findMipLevels`` que nous avons implémenté juste avant.

Le nombre de niveaux pour cette image est calculé de cette manière :

```
floor(log2(min(16, 16)) + 1) = floor(log2(16)) + 1) = floor(4 + 1) = floor(5) = 5 
```

Nous aurons donc 5 niveaux de mipmaps, de taille 16x16 (taille originale), 8x8, 4x4, 2x2 et 1x1.

L'``usage`` contient ``VK_IMAGE_USAGE_SAMPLED_BIT``, ce qui signifie que notre image sera échantillonnée dans un *shader*, ce qui est le principe des textures, mais aussi ``VK_IMAGE_USAGE_TRANSFER_SRC_BIT`` et ``VK_IMAGE_USAGE_TRANSFER_DST_BIT``, ce qui signifie que nous allons transferer des données depuis et vers cette image dans le GPU.

L'``usage`` de l'allocation est ``VMA_MEMORY_USAGE_AUTO_PREFER_DEVICE``, le CPU n'y aura donc pas accès.

Nous pouvons ensuite créer sa vue :

```CPP
VkImageView textureImageView;

VkImageViewCreateInfo textureImageViewCreateInfo = {};
textureImageViewCreateInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
textureImageViewCreateInfo.pNext = nullptr;
textureImageViewCreateInfo.flags = 0;
textureImageViewCreateInfo.image = textureImage;
textureImageViewCreateInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;
textureImageViewCreateInfo.format = VK_FORMAT_R8G8B8A8_SRGB;
textureImageViewCreateInfo.components.r = VK_COMPONENT_SWIZZLE_R;
textureImageViewCreateInfo.components.g = VK_COMPONENT_SWIZZLE_G;
textureImageViewCreateInfo.components.b = VK_COMPONENT_SWIZZLE_B;
textureImageViewCreateInfo.components.a = VK_COMPONENT_SWIZZLE_A;
textureImageViewCreateInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
textureImageViewCreateInfo.subresourceRange.baseMipLevel = 0;
textureImageViewCreateInfo.subresourceRange.levelCount = textureImageCreateInfo.mipLevels;
textureImageViewCreateInfo.subresourceRange.baseArrayLayer = 0;
textureImageViewCreateInfo.subresourceRange.layerCount = 1;
TUTORIEL_VK_CHECK(vkCreateImageView(m_device, &textureImageViewCreateInfo, nullptr, &textureImageView));
```

Il est intéressant de noter que nous souhaitons avoir accès à tous les niveaux de mipmaps dans cette vue, donc ``levelCount`` est égal à ``textureImageCreateInfo.mipLevels``, qui est utilisé lors de la création de l'image, et qui est égal à 5 ici.

Nous avons maintenant besoin de créer un *Staging Buffer*, comme lors de la création des *Vertex* et *Index Buffers* pour pouvoir y copier les valeurs des pixels depuis le CPU puis les copier dans notre image de texture :

```CPP
// Staging buffer
VkBuffer textureStagingBuffer;
VmaAllocation textureStagingBufferAllocation;

VkBufferCreateInfo textureStagingBufferCreateInfo = {};
textureStagingBufferCreateInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
textureStagingBufferCreateInfo.pNext = nullptr;
textureStagingBufferCreateInfo.flags = 0;
textureStagingBufferCreateInfo.size = 16 * 16 * 4;
textureStagingBufferCreateInfo.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
textureStagingBufferCreateInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
textureStagingBufferCreateInfo.queueFamilyIndexCount = 1;
textureStagingBufferCreateInfo.pQueueFamilyIndices = &m_graphicsQueueFamilyIndex;

VmaAllocationCreateInfo textureStagingBufferAllocationCreateInfo = {};
textureStagingBufferAllocationCreateInfo.usage = VMA_MEMORY_USAGE_AUTO_PREFER_HOST;
textureStagingBufferAllocationCreateInfo.flags = VMA_ALLOCATION_CREATE_HOST_ACCESS_SEQUENTIAL_WRITE_BIT;
TUTORIEL_VK_CHECK(vmaCreateBuffer(m_allocator, &textureStagingBufferCreateInfo, &textureStagingBufferAllocationCreateInfo, &textureStagingBuffer, &textureStagingBufferAllocation, nullptr));

void* data;
TUTORIEL_VK_CHECK(vmaMapMemory(m_allocator, textureStagingBufferAllocation, &data));
memcpy(data, textureData.data(), 16 * 16 * 4);
vmaUnmapMemory(m_allocator, textureStagingBufferAllocation);
```

La taille de ce *Staging Buffer* est de ``16 * 16 * 4`` car l'image est de taille 16 pixels par 16 pixels où chaque pixel possède 4 composantes de 1 octet.

Nous devons ensuite créer un *Command Pool* pour y allouer un *Command Buffer* afin de transitionner tous les niveaux de mipmaps de l'image vers le layout ``VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`` :

```CPP
// Copie du staging buffer et generation des mipmaps
VkCommandPool buffersCopyCommandPool;

VkCommandPoolCreateInfo buffersCopyCommandPoolCreateInfo = {};
buffersCopyCommandPoolCreateInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
buffersCopyCommandPoolCreateInfo.pNext = nullptr;
buffersCopyCommandPoolCreateInfo.flags = 0;
buffersCopyCommandPoolCreateInfo.queueFamilyIndex = m_graphicsQueueFamilyIndex;
TUTORIEL_VK_CHECK(vkCreateCommandPool(m_device, &buffersCopyCommandPoolCreateInfo, nullptr, &buffersCopyCommandPool));

VkCommandBuffer buffersCopyCommandBuffer;

VkCommandBufferAllocateInfo buffersCopyCommandBufferAllocateInfo = {};
buffersCopyCommandBufferAllocateInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
buffersCopyCommandBufferAllocateInfo.pNext = nullptr;
buffersCopyCommandBufferAllocateInfo.commandPool = buffersCopyCommandPool;
buffersCopyCommandBufferAllocateInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
buffersCopyCommandBufferAllocateInfo.commandBufferCount = 1;
TUTORIEL_VK_CHECK(vkAllocateCommandBuffers(m_device, &buffersCopyCommandBufferAllocateInfo, &buffersCopyCommandBuffer));

VkImageMemoryBarrier2 undefinedToTransferDstOptimalImageMemoryBarrier = {};
undefinedToTransferDstOptimalImageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2;
undefinedToTransferDstOptimalImageMemoryBarrier.pNext = nullptr;
undefinedToTransferDstOptimalImageMemoryBarrier.srcStageMask = VK_PIPELINE_STAGE_2_NONE;
undefinedToTransferDstOptimalImageMemoryBarrier.srcAccessMask = 0;
undefinedToTransferDstOptimalImageMemoryBarrier.dstStageMask = VK_PIPELINE_STAGE_2_COPY_BIT;
undefinedToTransferDstOptimalImageMemoryBarrier.dstAccessMask = VK_ACCESS_2_TRANSFER_WRITE_BIT;
undefinedToTransferDstOptimalImageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
undefinedToTransferDstOptimalImageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
undefinedToTransferDstOptimalImageMemoryBarrier.srcQueueFamilyIndex = m_graphicsQueueFamilyIndex;
undefinedToTransferDstOptimalImageMemoryBarrier.dstQueueFamilyIndex = m_graphicsQueueFamilyIndex;
undefinedToTransferDstOptimalImageMemoryBarrier.image = textureImage;
undefinedToTransferDstOptimalImageMemoryBarrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
undefinedToTransferDstOptimalImageMemoryBarrier.subresourceRange.baseMipLevel = 0;
undefinedToTransferDstOptimalImageMemoryBarrier.subresourceRange.levelCount = textureImageCreateInfo.mipLevels;
undefinedToTransferDstOptimalImageMemoryBarrier.subresourceRange.baseArrayLayer = 0;
undefinedToTransferDstOptimalImageMemoryBarrier.subresourceRange.layerCount = 1;

VkDependencyInfo undefinedToTransferDstOptimalDependencyInfo = {};
undefinedToTransferDstOptimalDependencyInfo.sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO;
undefinedToTransferDstOptimalDependencyInfo.pNext = nullptr;
undefinedToTransferDstOptimalDependencyInfo.dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;
undefinedToTransferDstOptimalDependencyInfo.memoryBarrierCount = 0;
undefinedToTransferDstOptimalDependencyInfo.pMemoryBarriers = nullptr;
undefinedToTransferDstOptimalDependencyInfo.bufferMemoryBarrierCount = 0;
undefinedToTransferDstOptimalDependencyInfo.pBufferMemoryBarriers = nullptr;
undefinedToTransferDstOptimalDependencyInfo.imageMemoryBarrierCount = 1;
undefinedToTransferDstOptimalDependencyInfo.pImageMemoryBarriers = &undefinedToTransferDstOptimalImageMemoryBarrier;
m_vkCmdPipelineBarrier2KHR(buffersCopyCommandBuffer, &undefinedToTransferDstOptimalDependencyInfo);
```

``dstStageMask`` est à ``VK_PIPELINE_STAGE_2_COPY_BIT`` car nous allons effectuer une opération de copie sur l'image et ``dstAccessMask`` est à ``VK_ACCESS_2_TRANSFER_WRITE_BIT`` car nous allons transférer et écrire des données dessus.

Puis nous pouvons copier les données du *Staging Buffer* qui contient les pixels de l'image vers l'image :

```CPP
VkBufferImageCopy textureBufferCopy = {};
textureBufferCopy.bufferOffset = 0;
textureBufferCopy.bufferRowLength = 0;
textureBufferCopy.bufferImageHeight = 0;
textureBufferCopy.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
textureBufferCopy.imageSubresource.mipLevel = 0;
textureBufferCopy.imageSubresource.baseArrayLayer = 0;
textureBufferCopy.imageSubresource.layerCount = 1;
textureBufferCopy.imageOffset.x = 0;
textureBufferCopy.imageOffset.y = 0;
textureBufferCopy.imageOffset.z = 0;
textureBufferCopy.imageExtent.width = 16;
textureBufferCopy.imageExtent.height = 16;
textureBufferCopy.imageExtent.depth = 1;
vkCmdCopyBufferToImage(buffersCopyCommandBuffer, textureStagingBuffer, textureImage, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &textureBufferCopy);
```

La copie de données d'un *buffer* vers une image se fait avec la commande [**``vkCmdCopyBufferToImage``**](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdCopyBufferToImage.html) et la structure [**``VkBufferImageCopy``**](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkBufferImageCopy.html).

``bufferOffset`` est un décalage en octet dans le *buffer* source, mais nous utilisons tout le *buffer*, donc la valeur est 0.

``bufferRowLength`` et ``bufferImageHeight`` sont utilisés lorsque les données de l'image que nous voulons copier n'est pas consécutive dans la mémoire du *buffer*, ce qui n'est pas notre cas ici.

``mipLevel`` est à 0 car nous voulons copier nos données dans le niveau 0 de mipmap, qui est le niveau original de taille 16 pixels par 16 pixels. Il est possible de définir soi-même les pixels de chaque niveau de mipmap à la main mais nous allons les générer automatiquement.

``imageOffset`` spécifie un décalage en pixels dans l'image lors de la copie, notre image va être entiérement écrite avec cette opération de copie donc nous n'avons pas de décalage.

``imageExtent`` est la taille de l'image à copier, donc ici, 16 pixels de largeur ``width`` et 16 pixels de hauteur ``height``, ``depth`` est utilisé pour les images 3D, mais notre image est une image 2D.

``vkCmdCopyBufferToImage`` prend plusieurs paramètres :
- le *Command Buffer* dans lequel nous voulons ajouter cette commande,
- le *buffer* depuis lequel nous voulons copier les données, ici, notre *Staging Buffer*,
- l'image sur laquelle nous voulons les données du *buffer* source, ici, notre image de texture,
- le layout de l'image lors de l'opération de copie, ici, ``VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL``
- le nombre de copies à effectuer, une seule ici,
- les structures ``VkBufferImageCopy`` qui spécifient les copies à effectuer.

Nous allons ensuite générer automatiquement les niveaux de mipmaps grâce à une opération de copie d'images appelée *Blit*, qui permet de copier une image vers une autre image en spécifiant un filtre, donc, ici, du niveau *n* de mipmap au niveau *n+1* avec une interpolation linéaire.

La synchronisation est très importante aussi car nous ne voulons pas, par exemple, commencer la copie du niveau 2 au niveau 3 si la copie du niveau 1 au niveau 2 n'est toujours pas terminée.

![Génération des mipmaps](images/generation_mipmaps.png)

Une fois qu'un niveau a effectué le *Blit* vers le niveau suivant, une barrière transitionne son layout de ``VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`` vers ``VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL``, le rendant prêt à être lu dans un *shader*.

Une fois qu'un niveau a reçu ses données par un *Blit* depuis le niveau précédent, une barrière transitionne son layout de ``VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`` vers ``VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`` pour qu'il puisse à son tour *Blit* vers le niveau suivant.

```CPP
VkImageMemoryBarrier2 mipMapGenerationImageMemoryBarrier = {};
mipMapGenerationImageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2;
mipMapGenerationImageMemoryBarrier.pNext = nullptr;
mipMapGenerationImageMemoryBarrier.srcQueueFamilyIndex = m_graphicsQueueFamilyIndex;
mipMapGenerationImageMemoryBarrier.dstQueueFamilyIndex = m_graphicsQueueFamilyIndex;
mipMapGenerationImageMemoryBarrier.image = textureImage;
mipMapGenerationImageMemoryBarrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
mipMapGenerationImageMemoryBarrier.subresourceRange.levelCount = 1;
mipMapGenerationImageMemoryBarrier.subresourceRange.baseArrayLayer = 0;
mipMapGenerationImageMemoryBarrier.subresourceRange.layerCount = 1;

uint32_t mipWidth = textureImageCreateInfo.extent.width;
uint32_t mipHeight = textureImageCreateInfo.extent.height;
for (size_t i = 1; i < textureImageCreateInfo.mipLevels; i++) {
	mipMapGenerationImageMemoryBarrier.srcStageMask = VK_PIPELINE_STAGE_2_COPY_BIT;
	mipMapGenerationImageMemoryBarrier.srcAccessMask = VK_ACCESS_2_TRANSFER_WRITE_BIT;
	mipMapGenerationImageMemoryBarrier.dstStageMask = VK_PIPELINE_STAGE_2_COPY_BIT;
	mipMapGenerationImageMemoryBarrier.dstAccessMask = VK_ACCESS_2_TRANSFER_READ_BIT;
	mipMapGenerationImageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
	mipMapGenerationImageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
	mipMapGenerationImageMemoryBarrier.subresourceRange.baseMipLevel = static_cast<uint32_t>(i) - 1;

	VkDependencyInfo mipMapGenerationDependencyInfo = {};
	mipMapGenerationDependencyInfo.sType = VK_STRUCTURE_TYPE_DEPENDENCY_INFO;
	mipMapGenerationDependencyInfo.pNext = nullptr;
	mipMapGenerationDependencyInfo.dependencyFlags = VK_DEPENDENCY_BY_REGION_BIT;
	mipMapGenerationDependencyInfo.memoryBarrierCount = 0;
	mipMapGenerationDependencyInfo.pMemoryBarriers = nullptr;
	mipMapGenerationDependencyInfo.bufferMemoryBarrierCount = 0;
	mipMapGenerationDependencyInfo.pBufferMemoryBarriers = nullptr;
	mipMapGenerationDependencyInfo.imageMemoryBarrierCount = 1;
	mipMapGenerationDependencyInfo.pImageMemoryBarriers = &mipMapGenerationImageMemoryBarrier;
	m_vkCmdPipelineBarrier2KHR(buffersCopyCommandBuffer, &mipMapGenerationDependencyInfo);

	VkImageBlit imageBlit = {};
	imageBlit.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
	imageBlit.srcSubresource.mipLevel = static_cast<uint32_t>(i) - 1;
	imageBlit.srcSubresource.baseArrayLayer = 0;
	imageBlit.srcSubresource.layerCount = 1;
	imageBlit.srcOffsets[0].x = 0;
	imageBlit.srcOffsets[0].y = 0;
	imageBlit.srcOffsets[0].z = 0;
	imageBlit.srcOffsets[1].x = mipWidth;
	imageBlit.srcOffsets[1].y = mipHeight;
	imageBlit.srcOffsets[1].z = 1;
	imageBlit.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
	imageBlit.dstSubresource.mipLevel = static_cast<uint32_t>(i);
	imageBlit.dstSubresource.baseArrayLayer = 0;
	imageBlit.dstSubresource.layerCount = 1;
	imageBlit.dstOffsets[0].x = 0;
	imageBlit.dstOffsets[0].y = 0;
	imageBlit.dstOffsets[0].z = 0;
	imageBlit.dstOffsets[1].x = mipWidth > 1 ? mipWidth / 2 : 1;
	imageBlit.dstOffsets[1].y = mipHeight > 1 ? mipHeight / 2 : 1;
	imageBlit.dstOffsets[1].z = 1;
	vkCmdBlitImage(buffersCopyCommandBuffer, textureImage, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, textureImage, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &imageBlit, VK_FILTER_LINEAR);

	mipMapGenerationImageMemoryBarrier.srcStageMask = VK_PIPELINE_STAGE_2_COPY_BIT;
	mipMapGenerationImageMemoryBarrier.srcAccessMask = VK_ACCESS_2_TRANSFER_READ_BIT;
	mipMapGenerationImageMemoryBarrier.dstStageMask = VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT;
	mipMapGenerationImageMemoryBarrier.dstAccessMask = VK_ACCESS_2_SHADER_SAMPLED_READ_BIT;
	mipMapGenerationImageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
	mipMapGenerationImageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;

	mipMapGenerationDependencyInfo.pImageMemoryBarriers = &mipMapGenerationImageMemoryBarrier;
	m_vkCmdPipelineBarrier2KHR(buffersCopyCommandBuffer, &mipMapGenerationDependencyInfo);

	mipWidth = mipWidth > 1 ? mipWidth / 2 : 1;
	mipHeight = mipHeight > 1 ? mipHeight / 2 : 1;
}
```

Nous avons donc ici une boucle qui commence du niveau 1 de mipmap (le niveau 0 a déjà ses pixels grâce au *Staging Buffer*) et qui va jusqu'au dernier niveau de mipmap.

À chaque tour de boucle, le layout du niveau de mipmap *i-1* transitionne de ``VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL`` vers ``VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL``.

Dans cette transition de layout, ``srcStageMask`` est ``VK_PIPELINE_STAGE_2_COPY_BIT`` car nous voulons attendre que la copie vers ce niveau de mipmap se termine, ``srcAccessMask`` est ``VK_ACCESS_2_TRANSFER_WRITE_BIT`` et signifie que nous avons écrit dans cette image lors d'un transfert, ``dstStageMask`` est aussi ``VK_PIPELINE_STAGE_2_COPY_BIT`` et signifie que cette image sera utilisée lors d'une opération de copie et ``dstAccessMask`` est ``VK_ACCESS_2_TRANSFER_READ_BIT`` et signifie que nous allons lire les données de cette image lors d'un transfert.

Puis un *Blit* est effectué avec la commande [**``vkCmdBlitImage``**](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/vkCmdBlitImage.html), qui utilise une structure [**``VkImageBlit``**](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageBlit.html).

``srcSubresource.mipLevel`` est le niveau de mipmap de l'image depuis lequel nous voulons copier les données, donc ici, le niveau *i-1*.

``srcOffsets[0]`` est le coin supérieur gauche de l'image source, ``srcOffsets[1]`` est le coin inférieur droit de l'image source. Cette zone est celle que nous voulons copier.

``dstSubresource.mipLevel`` est le niveau de mipmap de l'image vers laquelle nous allons copier les données, donc ici, le niveau *i*.

``dstOffsets[0]`` est le coin supérieur gauche de l'image destination, ``dstOffsets[1]`` est le coin inférieur droit de l'image destination. Cette zone est celle dans laquelle les données seront copiées.

``vkCmdBlitImage`` prend en paramètres :
- le *Command Buffer* dans lequel nous voulons ajouter cette commande,
- l'image source depuis laquelle nous voulons copier les données, qui est ici l'image de texture,
- le layout de l'image source depuis laquelle nous voulons copier les données, qui est ici ``VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`` grâce à la transition de layout effectuée juste avant,
- l'image destination vers laquelle nous voulons copier les données, qui est aussi l'image de texture, puisque nous copions des données depuis différents niveaux de mipmaps d'une même image,
- le layout de l'image destination dans laquelle nous voulons copier les données, qui est ici ``VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL``,
- le nombre d'opérations de copies, ici, 1,
- les structures ``VkImageBlit`` qui spécifient les opérations de copies,
- le filtre à utiliser lors de la copie. Puisque les images sont de taille différentes, nous pouvois choisir entre choisir le pixel le plus proche avec ``VK_FILTER_NEAREST`` ou effectuer une interpolation linéaire des pixels avec ``VK_FILTER_LINEAR``. Nous allons faire une interpolation linéaire.

Nous avons ensuite une autre barrière qui transitionne le layout du niveau *i-1* qui a fini de copier ses données au niveau *i* de ``VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL`` vers ``VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL``.

Dans cette transition de layout, ``srcStageMask`` est ``VK_PIPELINE_STAGE_2_COPY_BIT`` car nous voulons attendre que la copie se termine, ``srcAccessMask`` est ``VK_ACCESS_2_TRANSFER_READ_BIT`` et signifie que nous avons lu dans cette image lors d'un transfert, ``dstStageMask`` est ``VK_PIPELINE_STAGE_2_FRAGMENT_SHADER_BIT`` et signifie que cette image sera utilisée lors de l'étape de pipeline du *Fragment Shader* et ``dstAccessMask`` est ``VK_ACCESS_2_SHADER_SAMPLED_READ_BIT`` et signifie que nous allons échantillonner cette image dans un *shader*.

Enfin, nous calculons la largeur et la hauteur du niveau de mipmap suivant.